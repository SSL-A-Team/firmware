use std::path::Path;

fn generate_pitch_set(ref_freq: u16, octaves_below: i8, octaves_above: i8) -> Vec<(String, u16)>{
    // (Ref pitch is assumed to be A4)
    let mut pitches = Vec::<(String, u16)>::new();
    let scale : [&str; 12] = ["a", "as", "b", "c", "cs", "d", "ds", "e", "f", "fs", "g", "gs"];
    // Calculate ALL the pitches!
    for o in 1..octaves_below {
        for semitone in 0..11 {
            // vector of (pitch name, freq in hertz)
            // -12 semitones for each octave + number of semitones above A in that octave
            let freq = generate_pitch_from_reference(ref_freq, (-12 * o) + semitone);
            let pitch = (format!("{}{}", scale[semitone as usize], 4 - o), freq);
            pitches.push(pitch);
        }
    }
    // Start at 0 since we also have to include a4-a5
    // (starting with the reference pitch)
    for o in 0..octaves_above - 1 {
        for semitone in 0..11 {
            // vector of (pitch name, freq in hertz)
            // +12 semitones for each octave + number of semitones above A in that octave
            let freq = generate_pitch_from_reference(ref_freq, (12 * o) + semitone);
            let pitch = (format!("{}{}", scale[semitone as usize], 4 + o), freq);
            pitches.push(pitch);
        }
    }
    pitches
}

fn write_pitches_to_file(pitch_set: Vec<(String, u16)>){
    // I think this matters as Git will convert line endings, so we
    // don't want to invalidate the cache because our 
    #[cfg(windows)]
    const LINE_ENDING: &'static str = "\r\n";
    #[cfg(not(windows))]
    const LINE_ENDING: &'static str = "\n";
    
    let mut generated_file_contents = String::new();
    generated_file_contents.push_str("// This file is autogenerated by build.rs");
    generated_file_contents.push_str(LINE_ENDING);
    generated_file_contents.push_str(LINE_ENDING);
    for pitch in pitch_set {
        // Write each pitch name as a constant
        // in the format PITCH_NAME_OCTAVE, ex. 
        // pub const A4: u16 = 440
        generated_file_contents.push_str(format!("pub const {}: u16 = {};{}", pitch.0.to_uppercase(), pitch.1, LINE_ENDING).as_str());
    }
    
    let pitches_file = Path::new("./src/audio/pitches.rs");
    let write_contents: bool = if !pitches_file.exists() {
        true
    } else {
        let file_contents = std::fs::read_to_string(pitches_file).expect("failed to open existing pitches file");

        if file_contents == generated_file_contents {
            false
        } else {
            true
        }
    };

    if write_contents {
        std::fs::write(pitches_file, generated_file_contents).expect("failed to write pitches file contents");
    }
}

fn generate_pitch_from_reference(ref_pitch: u16, semitones: i8) -> u16{
    let diff = semitones as f32 / 12_f32;
    (ref_pitch as f32/ 2_f32.powf(diff)) as u16
}

fn main() {
    let a4 = 440;
    let pitch_set = generate_pitch_set(a4, 2, 2);
    write_pitches_to_file(pitch_set);
}